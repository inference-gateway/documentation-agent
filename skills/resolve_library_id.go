// Code generated by ADL CLI v0.12.1 on 2025-09-03 01:05:03. DO NOT EDIT.
// This file was automatically generated from an ADL (Agent Definition Language) specification.
// Manual changes to this file may be overwritten during regeneration.

package skills

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strings"

	"github.com/go-resty/resty/v2"
	"github.com/inference-gateway/adk/server"
)

// SearchResult represents a library search result from Context7
type SearchResult struct {
	ID             string   `json:"id"`
	Title          string   `json:"title"`
	Description    string   `json:"description"`
	Branch         string   `json:"branch"`
	LastUpdateDate string   `json:"lastUpdateDate"`
	State          string   `json:"state"`
	TotalTokens    int      `json:"totalTokens"`
	TotalSnippets  int      `json:"totalSnippets"`
	TotalPages     int      `json:"totalPages"`
	Stars          *int     `json:"stars,omitempty"`
	TrustScore     *int     `json:"trustScore,omitempty"`
	Versions       []string `json:"versions,omitempty"`
}

// SearchResponse represents the response from Context7 search API
type SearchResponse struct {
	Error   string         `json:"error,omitempty"`
	Results []SearchResult `json:"results"`
}

// NewResolveLibraryIDSkill creates a new resolve_library_id skill
func NewResolveLibraryIDSkill() server.Tool {
	return server.NewBasicTool(
		"resolve_library_id",
		"Resolves library name to Context7-compatible library ID and returns matching libraries",
		map[string]any{
			"type": "object",
			"properties": map[string]any{
				"libraryName": map[string]any{
					"description": "Library name to search for and retrieve a Context7-compatible library ID",
					"type":        "string",
				},
			},
			"required": []string{"libraryName"},
		},
		ResolveLibraryIDHandler,
	)
}

// ResolveLibraryIDHandler handles the resolve_library_id skill execution
func ResolveLibraryIDHandler(ctx context.Context, args map[string]any) (string, error) {
	libraryName, ok := args["libraryName"].(string)
	if !ok {
		return "", fmt.Errorf("libraryName parameter is required and must be a string")
	}

	if strings.TrimSpace(libraryName) == "" {
		return "", fmt.Errorf("libraryName cannot be empty")
	}

	apiKey := os.Getenv("CONTEXT7_API_KEY")
	if apiKey == "" {
		return `{"error": "Context7 API key not configured. Please set CONTEXT7_API_KEY environment variable"}`, nil
	}

	client := resty.New()

	resp, err := client.R().
		SetHeader("Authorization", fmt.Sprintf("Bearer %s", apiKey)).
		SetHeader("User-Agent", "documentation-agent/0.1.0").
		SetQueryParam("query", libraryName).
		Get("https://context7.com/api/v1/search")

	if err != nil {
		return "", fmt.Errorf("failed to make request to Context7 API: %w", err)
	}

	if resp.StatusCode() != http.StatusOK {
		if resp.StatusCode() == http.StatusUnauthorized {
			return `{"error": "Invalid Context7 API key. Please check your CONTEXT7_API_KEY environment variable"}`, nil
		}
		return "", fmt.Errorf("Context7 API returned status %d: %s", resp.StatusCode(), resp.String())
	}

	var searchResponse SearchResponse
	if err := json.Unmarshal(resp.Body(), &searchResponse); err != nil {
		return "", fmt.Errorf("failed to parse Context7 API response: %w", err)
	}

	if searchResponse.Error != "" {
		return fmt.Sprintf(`{"error": "%s"}`, searchResponse.Error), nil
	}

	if len(searchResponse.Results) == 0 {
		return fmt.Sprintf(`{"error": "No libraries found matching '%s'"}`, libraryName), nil
	}

	var selectedResult *SearchResult

	for i := range searchResponse.Results {
		result := &searchResponse.Results[i]
		if strings.EqualFold(result.Title, libraryName) {
			selectedResult = result
			break
		}
	}

	if selectedResult == nil {
		bestScore := -1
		for i := range searchResponse.Results {
			result := &searchResponse.Results[i]
			score := 0

			score += result.TotalSnippets

			if result.TrustScore != nil && *result.TrustScore >= 7 {
				score += *result.TrustScore * 10
			}

			if result.State == "finalized" {
				score += 100
			}

			if score > bestScore {
				bestScore = score
				selectedResult = result
			}
		}
	}

	if selectedResult == nil {
		selectedResult = &searchResponse.Results[0]
	}

	response := map[string]any{
		"selectedLibraryID": selectedResult.ID,
		"selectedLibrary": map[string]any{
			"id":             selectedResult.ID,
			"title":          selectedResult.Title,
			"description":    selectedResult.Description,
			"totalSnippets":  selectedResult.TotalSnippets,
			"totalTokens":    selectedResult.TotalTokens,
			"state":          selectedResult.State,
			"lastUpdateDate": selectedResult.LastUpdateDate,
		},
		"allMatches":   searchResponse.Results,
		"totalMatches": len(searchResponse.Results),
	}

	if selectedResult.TrustScore != nil {
		response["selectedLibrary"].(map[string]any)["trustScore"] = *selectedResult.TrustScore
	}
	if selectedResult.Stars != nil {
		response["selectedLibrary"].(map[string]any)["stars"] = *selectedResult.Stars
	}

	responseJson, err := json.Marshal(response)
	if err != nil {
		return "", fmt.Errorf("failed to marshal response: %w", err)
	}

	return string(responseJson), nil
}
