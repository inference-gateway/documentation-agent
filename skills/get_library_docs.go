// Code generated by ADL CLI v0.12.1 on 2025-09-03 01:05:03. DO NOT EDIT.
// This file was automatically generated from an ADL (Agent Definition Language) specification.
// Manual changes to this file may be overwritten during regeneration.

package skills

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strconv"
	"strings"

	"github.com/go-resty/resty/v2"
	"github.com/inference-gateway/adk/server"
)

// NewGetLibraryDocsSkill creates a new get_library_docs skill
func NewGetLibraryDocsSkill() server.Tool {
	return server.NewBasicTool(
		"get_library_docs",
		"Fetches up-to-date documentation for a library using Context7-compatible library ID",
		map[string]any{
			"type": "object",
			"properties": map[string]any{
				"context7CompatibleLibraryID": map[string]any{
					"description": "Exact Context7-compatible library ID (e.g., '/mongodb/docs', '/vercel/next.js', '/supabase/supabase') retrieved from resolve_library_id or directly from user query in the format '/org/project' or '/org/project/version'",
					"type":        "string",
				},
				"tokens": map[string]any{
					"description": "Maximum number of tokens of documentation to retrieve (default: 10000). Higher values provide more context but consume more tokens",
					"type":        "number",
				},
				"topic": map[string]any{
					"description": "Topic to focus documentation on (e.g., 'hooks', 'routing')",
					"type":        "string",
				},
			},
			"required": []string{"context7CompatibleLibraryID"},
		},
		GetLibraryDocsHandler,
	)
}

// GetLibraryDocsHandler handles the get_library_docs skill execution
func GetLibraryDocsHandler(ctx context.Context, args map[string]any) (string, error) {
	libraryID, ok := args["context7CompatibleLibraryID"].(string)
	if !ok {
		return "", fmt.Errorf("context7CompatibleLibraryID parameter is required and must be a string")
	}

	if strings.TrimSpace(libraryID) == "" {
		return "", fmt.Errorf("context7CompatibleLibraryID cannot be empty")
	}

	if !strings.HasPrefix(libraryID, "/") {
		return "", fmt.Errorf("context7CompatibleLibraryID must be in format '/org/project' or '/org/project/version', got: %s", libraryID)
	}

	tokens := 10000
	if tokensArg, exists := args["tokens"]; exists {
		switch v := tokensArg.(type) {
		case float64:
			tokens = int(v)
		case int:
			tokens = v
		case string:
			if parsed, err := strconv.Atoi(v); err == nil {
				tokens = parsed
			}
		}

		if tokens < 10000 {
			tokens = 10000
		}
	}

	topic := ""
	if topicArg, exists := args["topic"]; exists {
		if str, ok := topicArg.(string); ok {
			topic = strings.TrimSpace(str)
		}
	}

	apiKey := os.Getenv("CONTEXT7_API_KEY")
	if apiKey == "" {
		return `{"error": "Context7 API key not configured. Please set CONTEXT7_API_KEY environment variable"}`, nil
	}

	client := resty.New()

	apiURL := fmt.Sprintf("https://context7.com/api/v1%s", libraryID)

	req := client.R().
		SetHeader("Authorization", fmt.Sprintf("Bearer %s", apiKey)).
		SetHeader("User-Agent", "documentation-agent/0.1.0").
		SetQueryParam("type", "txt").
		SetQueryParam("tokens", strconv.Itoa(tokens))

	if topic != "" {
		req.SetQueryParam("topic", topic)
	}

	resp, err := req.Get(apiURL)

	if err != nil {
		return "", fmt.Errorf("failed to make request to Context7 API: %w", err)
	}

	if resp.StatusCode() != http.StatusOK {
		if resp.StatusCode() == http.StatusUnauthorized {
			return `{"error": "Invalid Context7 API key. Please check your CONTEXT7_API_KEY environment variable"}`, nil
		}
		if resp.StatusCode() == http.StatusNotFound {
			return fmt.Sprintf(`{"error": "Library not found: %s. Please check the library ID format and ensure it exists in Context7"}`, libraryID), nil
		}
		return "", fmt.Errorf("Context7 API returned status %d: %s", resp.StatusCode(), resp.String())
	}

	documentation := string(resp.Body())

	if strings.TrimSpace(documentation) == "" {
		return fmt.Sprintf(`{"error": "No documentation found for library: %s"}`, libraryID), nil
	}

	response := map[string]any{
		"libraryID":     libraryID,
		"documentation": documentation,
		"tokens":        tokens,
		"actualTokens":  len(strings.Fields(documentation)),
	}

	if topic != "" {
		response["topic"] = topic
	}

	responseJson, err := json.Marshal(response)
	if err != nil {
		return "", fmt.Errorf("failed to marshal response: %w", err)
	}

	return string(responseJson), nil
}
