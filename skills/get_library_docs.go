// Code generated by ADL CLI v0.12.1 on 2025-09-03 01:05:03. DO NOT EDIT.
// This file was automatically generated from an ADL (Agent Definition Language) specification.
// Manual changes to this file may be overwritten during regeneration.

package skills

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strconv"
	"strings"

	"github.com/go-resty/resty/v2"
	"github.com/inference-gateway/adk/server"
	"go.uber.org/zap"
)

// GetLibraryDocsSkill struct holds the skill with logger
type GetLibraryDocsSkill struct {
	logger *zap.Logger
}

// NewGetLibraryDocsSkill creates a new get_library_docs skill
func NewGetLibraryDocsSkill(logger *zap.Logger) server.Tool {
	skill := &GetLibraryDocsSkill{
		logger: logger,
	}
	return server.NewBasicTool(
		"get_library_docs",
		"Fetches up-to-date documentation for a library using Context7-compatible library ID",
		map[string]any{
			"type": "object",
			"properties": map[string]any{
				"context7CompatibleLibraryID": map[string]any{
					"description": "Exact Context7-compatible library ID (e.g., '/mongodb/docs', '/vercel/next.js', '/supabase/supabase') retrieved from resolve_library_id or directly from user query in the format '/org/project' or '/org/project/version'",
					"type":        "string",
				},
				"tokens": map[string]any{
					"description": "Maximum number of tokens of documentation to retrieve (default: 10000). Higher values provide more context but consume more tokens",
					"type":        "number",
				},
				"topic": map[string]any{
					"description": "Topic to focus documentation on (e.g., 'hooks', 'routing')",
					"type":        "string",
				},
			},
			"required": []string{"context7CompatibleLibraryID"},
		},
		skill.Handler,
	)
}

// Handler handles the get_library_docs skill execution
func (s *GetLibraryDocsSkill) Handler(ctx context.Context, args map[string]any) (string, error) {
	s.logger.Debug("GetLibraryDocs handler called", zap.Any("args", args))

	libraryID, ok := args["context7CompatibleLibraryID"].(string)
	if !ok {
		return "", fmt.Errorf("context7CompatibleLibraryID parameter is required and must be a string")
	}

	s.logger.Info("Fetching documentation", zap.String("libraryID", libraryID))

	if strings.TrimSpace(libraryID) == "" {
		return "", fmt.Errorf("context7CompatibleLibraryID cannot be empty")
	}

	if !strings.HasPrefix(libraryID, "/") {
		return "", fmt.Errorf("context7CompatibleLibraryID must be in format '/org/project' or '/org/project/version', got: %s", libraryID)
	}

	tokens := 10000
	if tokensArg, exists := args["tokens"]; exists {
		switch v := tokensArg.(type) {
		case float64:
			tokens = int(v)
		case int:
			tokens = v
		case string:
			if parsed, err := strconv.Atoi(v); err == nil {
				tokens = parsed
			}
		}

		if tokens < 10000 {
			tokens = 10000
		}
	}
	s.logger.Debug("Token limit configured", zap.Int("tokens", tokens))

	topic := ""
	if topicArg, exists := args["topic"]; exists {
		if str, ok := topicArg.(string); ok {
			topic = strings.TrimSpace(str)
		}
	}
	if topic != "" {
		s.logger.Debug("Filtering for topic", zap.String("topic", topic))
	}

	apiKey := os.Getenv("CONTEXT7_API_KEY")
	if apiKey == "" {
		s.logger.Warn("CONTEXT7_API_KEY not set, proceeding without authentication")
	} else {
		s.logger.Debug("Using Context7 API key", zap.String("keyPrefix", apiKey[:min(8, len(apiKey))]+"..."))
	}

	client := resty.New()
	if s.logger.Core().Enabled(zap.DebugLevel) {
		client.SetDebug(true)
	}

	mcpRequest := map[string]any{
		"jsonrpc": "2.0",
		"method":  "tools/call",
		"params": map[string]any{
			"name": "get-library-docs",
			"arguments": map[string]any{
				"context7CompatibleLibraryID": libraryID,
				"tokens":                      tokens,
			},
		},
		"id": "2",
	}

	if topic != "" {
		mcpRequest["params"].(map[string]any)["arguments"].(map[string]any)["topic"] = topic
	}

	req := client.R().
		SetHeader("User-Agent", "documentation-agent/0.1.0").
		SetHeader("Content-Type", "application/json").
		SetHeader("Accept", "application/json, text/event-stream").
		SetBody(mcpRequest)

	if apiKey != "" {
		req.SetHeader("CONTEXT7_API_KEY", apiKey)
	}

	apiURL := "https://mcp.context7.com/mcp"
	s.logger.Debug("Making MCP JSON-RPC request",
		zap.String("url", apiURL),
		zap.Any("requestBody", mcpRequest))

	resp, err := req.Post(apiURL)

	if err != nil {
		s.logger.Error("Request to Context7 MCP API failed", zap.Error(err))
		return "", fmt.Errorf("failed to make request to Context7 MCP API: %w", err)
	}

	responseBody := string(resp.Body())
	s.logger.Debug("Received response from Context7",
		zap.Int("statusCode", resp.StatusCode()),
		zap.String("body", truncateString(responseBody, 1000)))

	if resp.StatusCode() != http.StatusOK {
		if resp.StatusCode() == http.StatusUnauthorized {
			s.logger.Warn("Unauthorized access to Context7 API")
			return `{"error": "Invalid Context7 API key. Please check your CONTEXT7_API_KEY environment variable"}`, nil
		}
		if resp.StatusCode() == http.StatusNotFound {
			s.logger.Warn("Library not found", zap.String("libraryID", libraryID))
			return fmt.Sprintf(`{"error": "Library not found: %s. Please check the library ID format and ensure it exists in Context7"}`, libraryID), nil
		}

		var errorResp map[string]any
		if err := json.Unmarshal(resp.Body(), &errorResp); err == nil {
			if errMsg, ok := errorResp["error"].(string); ok {
				s.logger.Warn("Context7 API returned error", zap.String("error", errMsg))
				return fmt.Sprintf(`{"error": "%s"}`, errMsg), nil
			}
		}

		s.logger.Error("Context7 API returned non-OK status",
			zap.Int("statusCode", resp.StatusCode()),
			zap.String("response", resp.String()))
		return "", fmt.Errorf("Context7 MCP API returned status %d: %s", resp.StatusCode(), resp.String())
	}

	responseBody = string(resp.Body())

	var jsonData string
	lines := strings.Split(responseBody, "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "data: ") {
			jsonData = strings.TrimPrefix(line, "data: ")
			break
		}
	}

	if jsonData == "" {
		s.logger.Error("No JSON data found in SSE response", zap.String("response", truncateString(responseBody, 500)))
		return "", fmt.Errorf("no JSON data found in SSE response")
	}

	var mcpResponse map[string]any
	if err := json.Unmarshal([]byte(jsonData), &mcpResponse); err != nil {
		s.logger.Error("Failed to parse MCP response", zap.Error(err), zap.String("jsonData", truncateString(jsonData, 500)))
		return "", fmt.Errorf("failed to parse Context7 MCP response: %w", err)
	}

	if errorObj, ok := mcpResponse["error"]; ok {
		var errorMsg string
		if errMap, ok := errorObj.(map[string]any); ok {
			if msg, ok := errMap["message"].(string); ok {
				errorMsg = msg
			} else {
				errorMsg = fmt.Sprintf("%v", errorObj)
			}
		} else {
			errorMsg = fmt.Sprintf("%v", errorObj)
		}
		s.logger.Warn("MCP returned error", zap.String("error", errorMsg))
		if strings.Contains(errorMsg, "context7CompatibleLibraryID") {
			return fmt.Sprint(`{"error": "Parameter name mismatch - Context7 API may expect different field names"}`), nil
		}
		return fmt.Sprintf(`{"error": "%s"}`, errorMsg), nil
	}

	resultData, ok := mcpResponse["result"]
	if !ok {
		s.logger.Warn("No result field in MCP response, returning mock data")
		mockDocs := `# Next.js Documentation (Mock Response)

## Getting Started

This is a mock response while we implement proper MCP integration.

### Installation

npm install next react react-dom

### Basic Usage

Create pages in the pages directory and Next.js will automatically handle routing.`

		mockResponse := map[string]any{
			"libraryID":     libraryID,
			"documentation": mockDocs,
			"tokens":        tokens,
			"actualTokens":  len(strings.Fields(mockDocs)),
			"note":          "Using mock response - MCP integration pending",
		}

		responseJson, _ := json.Marshal(mockResponse)
		s.logger.Info("Returning mock documentation", zap.String("libraryID", libraryID))
		return string(responseJson), nil
	}

	var documentation string

	switch v := resultData.(type) {
	case string:
		documentation = v
	case map[string]any:
		if content, ok := v["content"].(string); ok {
			documentation = content
		} else if text, ok := v["text"].(string); ok {
			documentation = text
		} else if docs, ok := v["documentation"].(string); ok {
			documentation = docs
		} else {
			docsJson, _ := json.Marshal(v)
			documentation = string(docsJson)
		}
	default:
		docsJson, _ := json.Marshal(resultData)
		documentation = string(docsJson)
	}

	if strings.TrimSpace(documentation) == "" {
		s.logger.Warn("No documentation found", zap.String("libraryID", libraryID))
		return fmt.Sprintf(`{"error": "No documentation found for library: %s"}`, libraryID), nil
	}

	response := map[string]any{
		"libraryID":     libraryID,
		"documentation": documentation,
		"tokens":        tokens,
		"actualTokens":  len(strings.Fields(documentation)),
	}

	if topic != "" {
		response["topic"] = topic
	}

	responseJson, err := json.Marshal(response)
	if err != nil {
		s.logger.Error("Failed to marshal response", zap.Error(err))
		return "", fmt.Errorf("failed to marshal response: %w", err)
	}

	s.logger.Info("Successfully retrieved documentation", zap.String("libraryID", libraryID))
	return string(responseJson), nil
}
